      SUBROUTINE SCEUA(A,AF,BL,BU,NOPT,MAXN,KSTOP,PCENTO,ISEED,
     &                 NGS,NPG,NPS,NSPL,MINGS,INIFLG,IPRINT,ISCE)
C
C
C  SHUFFLED COMPLEX EVOLUTION METHOD FOR GLOBAL OPTIMIZATION
C     -- VERSION 2.1
C
C  BY QINGYUN DUAN
C  DEPARTMENT OF HYDROLOGY & WATER RESOURCES
C  UNIVERSITY OF ARIZONA, TUCSON, AZ 85721
C  (602) 621-9360, EMAIL: DUAN@HWR.ARIZONA.EDU
C
C  WRITTEN IN OCTOBER 1990.
C  REVISED IN AUGUST 1991
C  REVISED IN APRIL 1992
C
C  STATEMENT BY AUTHOR:
C  --------------------
C
C     THIS GENERAL PURPOSE GLOBAL OPTIMIZATION PROGRAM IS DEVELOPED AT
C     THE DEPARTMENT OF HYDROLOGY & WATER RESOURCES OF THE UNIVERSITY
C     OF ARIZONA.  FURTHER INFORMATION REGARDING THE SCE-UA METHOD CAN
C     BE OBTAINED FROM DR. Q. DUAN, DR. S. SOROOSHIAN OR DR. V.K. GUPTA
C     AT THE ADDRESS AND PHONE NUMBER LISTED ABOVE.  WE REQUEST ALL
C     USERS OF THIS PROGRAM MAKE PROPER REFERENCE TO THE PAPER ENTITLED
C     'EFFECTIVE AND EFFICIENT GLOBAL OPTIMIZATION FOR CONCEPTUAL
C     RAINFALL-RUNOFF MODELS' BY DUAN, Q., S. SOROOSHIAN, AND V.K. GUPTA,
C     WATER RESOURCES RESEARCH, VOL 28(4), PP.1015-1031, 1992.
C
C
C  LIST OF INPUT ARGUEMENT VARIABLES
C
C     A(.) = INITIAL PARAMETER SET
C     BL(.) = LOWER BOUND ON PARAMETERS
C     BU(.) = UPPER BOUND ON PARAMETERS
C     NOPT = NUMBER OF PARAMETERS TO BE OPTIMIZED
C
C
C  LIST OF SCE ALGORITHMIC CONTROL PARAMETERS:
C
C     NGS = NUMBER OF COMPLEXES IN THE INITIAL POPULATION
C     NPG = NUMBER OF POINTS IN EACH COMPLEX
C     NPT = TOTAL NUMBER OF POINTS IN INITIAL POPULATION (NPT=NGS*NPG)
C     NPS = NUMBER OF POINTS IN A SUB-COMPLEX
C     NSPL = NUMBER OF EVOLUTION STEPS ALLOWED FOR EACH COMPLEX BEFORE
C         COMPLEX SHUFFLING
C     MINGS = MINIMUM NUMBER OF COMPLEXES REQUIRED, IF THE NUMBER OF
C         COMPLEXES IS ALLOWED TO REDUCE AS THE OPTIMIZATION PROCEEDS
C     ISEED = INITIAL RANDOM SEED
C     INIFLG = FLAG ON WHETHER TO INCLUDE THE INITIAL POINT IN POPULATION
C         = 0, NOT INCLUDED
C         = 1, INCLUDED
C     IPRINT = FLAG FOR CONTROLLING PRINT-OUT AFTER EACH SHUFFLING LOOP
C         = 0, PRINT INFORMATION ON THE BEST POINT OF THE POPULATION
C         = 1, PRINT INFORMATION ON EVERY POINT OF THE POPULATION
C
C
C     MPC ADDITION
C
C     ISCE = UNIT NUMBER FOR SCE OUTPUT
C
C
C  CONVERGENCE CHECK PARAMETERS
C
C     MAXN = MAX NO. OF TRIALS ALLOWED BEFORE OPTIMIZATION IS TERMINATED
C     KSTOP = NUMBER OF SHUFFLING LOOPS IN WHICH THE CRITERION VALUE MUST
C         CHANG BY THE GIVEN PERCENTAGE BEFORE OPTIMIZATION IS TERMINATED
C     PCENTO = PERCENTAGE BY WHICH THE CRITERION VALUE MUST CHANGE IN
C         GIVEN NUMBER OF SHUFFLING LOOPS
C     IPCNVG = FLAG INDICATING WHETHER PARAMETER CONVERGENCE IS REACHED
C         (I.E., CHECK IF GNRNG IS LESS THAN 0.001)
C         = 0, PARAMETER CONVERGENCE NOT SATISFIED
C         = 1, PARAMETER CONVERGENCE SATISFIED
C
C
C  LIST OF LOCAL VARIABLES
C     X(.,.) = COORDINATES OF POINTS IN THE POPULATION
C     XF(.) = FUNCTION VALUES OF X(.,.)
C     XX(.) = COORDINATES OF A SINGLE POINT IN X
C     CX(.,.) = COORDINATES OF POINTS IN A COMPLEX
C     CF(.) = FUNCTION VALUES OF CX(.,.)
C     S(.,.) = COORDINATES OF POINTS IN THE CURRENT SIMPLEX
C     SF(.) = FUNCTION VALUES OF S(.,.)
C     BESTX(.) = BEST POINT AT CURRENT SHUFFLING LOOP
C     BESTF = FUNCTION VALUE OF BESTX(.)
C     WORSTX(.) = WORST POINT AT CURRENT SHUFFLING LOOP
C     WORSTF = FUNCTION VALUE OF WORSTX(.)
C     XNSTD(.) = STANDARD DEVIATION OF PARAMETERS IN THE POPULATION
C     GNRNG = NORMALIZED GEOMETRIC MEAN OF PARAMETER RANGES
C     LCS(.) = INDICES LOCATING POSITION OF S(.,.) IN X(.,.)
C     BOUND(.) = BOUND ON ITH VARIABLE BEING OPTIMIZED
C     NGS1 = NUMBER OF COMPLEXES IN CURRENT POPULATION
C     NGS2 = NUMBER OF COMPLEXES IN LAST POPULATION
C     ISEED1 = CURRENT RANDOM SEED
C     CRITER(.) = VECTOR CONTAINING THE BEST CRITERION VALUES OF THE LAST
C         10 SHUFFLING LOOPS
C

C      AJN ADDITION (02/21/2013)
C      CHANGED PARAMETER LIMIT TO IPARM, set IPARM=100

      INTEGER IPARM
      PARAMETER (IPARM=100)
      REAL FA

      CHARACTER*4 XNAME(IPARM)
C
C  ARRAYS FROM THE INPUT DATA
      DIMENSION A(IPARM),BL(IPARM),BU(IPARM)
C
C  LOCAL ARRAYS
      DIMENSION X(2000,IPARM),XX(IPARM),BESTX(IPARM)
      DIMENSION WORSTX(IPARM),XF(2000)
      DIMENSION S(50,IPARM),SF(50),LCS(50)
      DIMENSION CX(2000,IPARM),CF(2000)
      DIMENSION XNSTD(IPARM),BOUND(IPARM),CRITER(10)
      DIMENSION DIST(2000),XI(IPARM)

C
C
C  MPC REMOVE -- ISCE IS NOW AN ARGUMENT TO THE SUBROUTINE, OTHER VARS NOT USED
C
C      COMMON/IOPARS/ICNTRL,IOUT,IDAT,IWBAL,ISCE,IPE,IPC,IDET
C
      DATA XNAME /'  X1','  X2','  X3','  X4','  X5','  X6','  X7',
     &'  X8','  X9',' X10',' X11',' X12',' X13',' X14',' X15',' X16',
     &' X17',' X18',' X19',' X20',' X21',' X22',' X23',' X24',' X25',
     &' X26',' X27',' X28',' X29',' X30',' X31',' X32',' X33',' X34',
     &' X35',' X36',' X37',' X38',' X39',' X40',' X41',' X42',' X43',
     &' X44',' X45',' X46',' X47',' X48',' X49',' X50',' X51',' X52',
     &' X53',' X54',' X55',' X56',' X57',' X58',' X59',' X60',' X61',
     &' X62',' X63',' X64',' X65',' X66',' X67',' X68',' X69',' X70',
     &' X71',' X72',' X73',' X74',' X75',' X76',' X77',' X78',' X79',
     &' X80',' X81',' X82',' X83',' X84',' X85',' X86',' X87',' X88',
     &' X89',' X90',' X91',' X92',' X93',' X94',' X95',' X96',' X97',
     &' X98',' X99','X100'/

C
C  INITIALIZE VARIABLES
C      OPEN(ISCE,FILE='/d1/anewman/sacsnow17/foo.txt')
C      OPEN(ISCE,FILE=trim(scename))
      WRITE(ISCE,400)
  400 FORMAT(//,2X,50(1H=),/,2X,'ENTER THE SHUFFLED COMPLEX EVOLUTION',
     &       ' GLOBAL SEARCH',/,2X,50(1H=))
      WRITE(*,400)
      NLOOP = 0
      LOOP = 0
      IGS = 0
C
C  INITIALIZE RANDOM SEED TO A NEGATIVE INTEGER
      ISEED1 = -ABS(ISEED)
C
C  COMPUTE THE TOTAL NUMBER OF POINTS IN INITIAL POPUALTION
      NPT = NGS * NPG
      NGS1 = NGS
      NPT1 = NPT
C
C  COMPUTE THE BOUND FOR PARAMETERS BEING OPTIMIZED
      DO J = 1, NOPT
        BOUND(J) = BU(J) - BL(J)
        XI(J)    = A(J)
      END DO
      print *,'INTIAL PARAMETER VALUES IN SCE SUBROUTINE',A(1:NOPT)
      print *,'LOWER BOUND IN SCE SUBROUTINE',BL(1:NOPT)
      print *,'UPPER BOUND IN SCE SUBROUTINE',BU(1:NOPT)
C
C  COMPUTE THE FUNCTION VALUE OF THE INITIAL POINT
      FA = FUNCTN(NOPT,A)
C      print *,a(48),a(49),a(50),a(51),a(52)
      PRINT *, 'FUNCTION VALUE OF THE INITIAL POINT', FA
C
C  PRINT THE INITIAL POINT AND ITS CRITERION VALUE
      WRITE(ISCE,500)
      WRITE(*,   500)
      WRITE(ISCE,510) (XNAME(J),J=1,NOPT)
      WRITE(*,   510) (XNAME(J),J=1,NOPT)
      WRITE(ISCE,520) FA,(A(J),J=1,NOPT)
      WRITE(*,   520) FA,(A(J),J=1,NOPT)
C      print *,a(48),a(49),a(50),a(51),a(52)
!       print *,a(20)

      IF (MAXN .EQ. 1) GO TO 10000
C
C  GENERATE AN INITIAL SET OF NPT1 POINTS IN THE PARAMETER SPACE
C  IF INIFLG IS EQUAL TO 1, SET X(1,.) TO INITIAL POINT A(.)
      IF (INIFLG .EQ. 1) THEN
        DO J = 1, NOPT
          X(1,J) = A(J)
        END DO
        XF(1) = FA
C
C  ELSE, GENERATE A POINT RANDOMLY AND SET IT EQUAL TO X(1,.)
      ELSE
        DO J = 1, NOPT
          RAND = RAN1(ISEED1)
          X(1,J) = BL(J) + BOUND(J) * RAND
          XX(J) = X(1,J)
        END DO
        XF(1) = FUNCTN(NOPT,XX)
        print *,'function xx',XX(13),BL(13),BU(13)

      END IF
      ICALL = 1
      IF (ICALL .GE. MAXN) GO TO 9000
C
C  GENERATE NPT1-1 RANDOM POINTS DISTRIBUTED UNIFORMLY IN THE PARAMETER
C  SPACE, AND COMPUTE THE CORRESPONDING FUNCTION VALUES
      DO I = 2, NPT1
        DO J = 1, NOPT
          RAND = RAN1(ISEED1)
          X(I,J) = BL(J) + BOUND(J) * RAND
          XX(J) = X(I,J)
        END DO

        XF(I) = FUNCTN(NOPT,XX)
        ICALL = ICALL + 1
        IF (ICALL .GE. MAXN) THEN
          NPT1 = I
          GO TO 45
        END IF
      END DO
C

C  ARRANGE THE POINTS IN ORDER OF INCREASING FUNCTION VALUE
   45 CALL SORT(NPT1,NOPT,X,XF,IPARM)
C
C  RECORD THE BEST AND WORST POINTS
      DO J = 1, NOPT
        BESTX(J) = X(1,J)
        WORSTX(J) = X(NPT1,J)
      END DO
      BESTF = XF(1)
      WORSTF = XF(NPT1)
      PRINT *, 'BESTF:', BESTF
      PRINT *, 'WORSTF:', WORSTF

C
C  COMPUTE THE PARAMETER RANGE FOR THE INITIAL POPULATION
      CALL PARSTT(NPT1,NOPT,X,XNSTD,BOUND,GNRNG,IPCNVG,IPARM)
C
C  COMPUTE THE PARAMETER DISTANCE FROM THE INITIAL POPULATION
      CALL NORMDIST(NPT,NOPT,X,XI,DIST,BOUND,IPARM)
C
C  PRINT THE RESULTS FOR THE INITIAL POPULATION
      WRITE(ISCE,600)
      WRITE(*,   600)
      WRITE(ISCE,610) (XNAME(J),J=1,NOPT)
      WRITE(*,   610) (XNAME(J),J=1,NOPT)
      WRITE(ISCE,630) NLOOP,ICALL,NGS1,BESTF,WORSTF,DIST(1),
     &               (BESTX(J),J=1,NOPT)
      WRITE(*,   630) NLOOP,ICALL,NGS1,BESTF,WORSTF,DIST(1),
     &               (BESTX(J),J=1,NOPT)

      IF (IPRINT .EQ. 1) THEN
        WRITE(ISCE,650) NLOOP
        DO I = 1, NPT1
          WRITE(ISCE,660) XF(I),DIST(I),(X(I,J),J=1,NOPT)
        END DO
      END IF
C
      IF (ICALL .GE. MAXN) GO TO 9000
      IF (IPCNVG .EQ. 1) GO TO 9200
C
C  BEGIN THE MAIN LOOP ----------------
 1000 CONTINUE
      NLOOP = NLOOP + 1
C
C  BEGIN LOOP ON COMPLEXES
      DO IGS = 1, NGS1
C
C  ASSIGN POINTS INTO COMPLEXES
      DO K1 = 1, NPG
        K2 = (K1-1) * NGS1 + IGS
        DO J = 1, NOPT
          CX(K1,J) = X(K2,J)
        END DO
        CF(K1) = XF(K2)
      END DO
C
C  BEGIN INNER LOOP - RANDOM SELECTION OF SUB-COMPLEXES ---------------
      DO 2000 LOOP = 1, NSPL
C
C  CHOOSE A SUB-COMPLEX (NPS POINTS) ACCORDING TO A LINEAR
C  PROBABILITY DISTRIBUTION
      IF (NPS .EQ. NPG) THEN
        DO K = 1, NPS
          LCS(K) = K
        END DO
        GO TO 85
      END IF
C
      RAND = RAN1(ISEED1)
      LCS(1) = 1 + INT(NPG + 0.5 - SQRT( (NPG+.5)**2 -
     &         NPG * (NPG+1) * RAND ))
      DO K = 2, NPS
   60   RAND = RAN1(ISEED1)
        LPOS = 1 + INT(NPG + 0.5 - SQRT((NPG+.5)**2 -
     &         NPG * (NPG+1) * RAND ))
        DO K1 = 1, K-1
          IF (LPOS .EQ. LCS(K1)) GO TO 60
        END DO
        LCS(K) = LPOS
      END DO
C
C  ARRANGE THE SUB-COMPLEX IN ORDER OF INCEASING FUNCTION VALUE
      CALL SORT1(NPS,LCS)
C
C  CREATE THE SUB-COMPLEX ARRAYS
   85 DO K = 1, NPS
        DO J = 1, NOPT
          S(K,J) = CX(LCS(K),J)
        END DO
        SF(K) = CF(LCS(K))
      END DO
C
C  USE THE SUB-COMPLEX TO GENERATE NEW POINT(S)
      CALL CCE(NOPT,NPS,S,SF,BL,BU,XNSTD,ICALL,
     &         MAXN,ISEED1,IPARM)

C
C  MPC ADDITION
      !print *, nloop, igs, loop, icall

C
C  IF THE SUB-COMPLEX IS ACCEPTED, REPLACE THE NEW SUB-COMPLEX
C  INTO THE COMPLEX
      DO K = 1, NPS
        DO J = 1, NOPT
          CX(LCS(K),J) = S(K,J)
        END DO
        CF(LCS(K)) = SF(K)
      END DO
C
C  SORT THE POINTS
      CALL SORT(NPG,NOPT,CX,CF,IPARM)
C
C  IF MAXIMUM NUMBER OF RUNS EXCEEDED, BREAK OUT OF THE LOOP
      IF (ICALL .GE. MAXN) GO TO 2222
C
C  END OF INNER LOOP ------------
 2000 CONTINUE
 2222 CONTINUE
C
C  REPLACE THE NEW COMPLEX INTO ORIGINAL ARRAY X(.,.)
      DO K1 = 1, NPG
        K2 = (K1-1) * NGS1 + IGS
        DO J = 1, NOPT
          X(K2,J) = CX(K1,J)
        END DO
        XF(K2) = CF(K1)
      END DO
      IF (ICALL .GE. MAXN) GO TO 3333
C
C  END LOOP ON COMPLEXES
      END DO
 3333 CONTINUE
C
C  RE-SORT THE POINTS
      CALL SORT(NPT1,NOPT,X,XF,IPARM)
C
C  RECORD THE BEST AND WORST POINTS
      DO J = 1, NOPT
        BESTX(J) = X(1,J)
        WORSTX(J) = X(NPT1,J)
      END DO
      BESTF = XF(1)
      WORSTF = XF(NPT1)
C
C  TEST THE POPULATION FOR PARAMETER CONVERGENCE
      CALL PARSTT(NPT1,NOPT,X,XNSTD,BOUND,GNRNG,IPCNVG,IPARM)
C
C  COMPUTE THE PARAMETER DISTANCE FROM THE INITIAL POPULATION
      CALL NORMDIST(NPT,NOPT,X,XI,DIST,BOUND,IPARM)
C
C  PRINT THE RESULTS FOR CURRENT POPULATION
      WRITE(ISCE,630) NLOOP,ICALL,NGS1,BESTF,WORSTF,DIST(1),
     &               (BESTX(J),J=1,NOPT)
      WRITE(*,630) NLOOP,ICALL,NGS1,BESTF,WORSTF,DIST(1),
     &               (BESTX(J),J=1,NOPT)
      IF (IPRINT .EQ. 1) THEN
        WRITE(ISCE,650) NLOOP
        DO I = 1, NPT1
          WRITE(ISCE,660) XF(I),DIST(I),(X(I,J),J=1,NOPT)
        END DO
      END IF
C
C  TEST IF MAXIMUM NUMBER OF FUNCTION EVALUATIONS EXCEEDED
      IF (ICALL .GE. MAXN) GO TO 9000
C
C  COMPUTE THE COUNT ON SUCCESSIVE LOOPS W/O FUNCTION IMPROVEMENT
      CRITER(10) = BESTF
      IF (NLOOP .LT. (KSTOP+1)) GO TO 132
      DENOMI = ABS(CRITER(10-KSTOP) + CRITER(10)) / 2.
      !PRINT *, 'ABOUT TO DIVIDE BY', DENOMI
      TIMEOU = ABS(CRITER(10-KSTOP) - CRITER(10)) / DENOMI
      IF (TIMEOU .LT. PCENTO) GO TO 9100
  132 CONTINUE
      DO L = 1, 9
        CRITER(L) = CRITER(L+1)
      END DO
C
C  IF POPULATION IS CONVERGED INTO A SUFFICIENTLY SMALL SPACE
      IF (IPCNVG .EQ. 1) GO TO 9200
C
C  NONE OF THE STOPPING CRITERIA IS SATISFIED, CONTINUE SEARCH
      print *, 'NONE OF THE STOPPING CRITERIA IS SATISFIED AFTER ',ICALL,' FUNCTION EVALUATIONS'
      print *, 'KEEP SEARCHING'
C
C  CHECK FOR COMPLEX NUMBER REDUCTION
      IF (NGS1 .GT .MINGS) THEN
        NGS2 = NGS1
        NGS1 = NGS1 - 1
        NPT1 = NGS1 * NPG
        CALL COMP(NOPT,NPT1,NGS1,NGS2,NPG,X,XF,CX,CF,IPARM)
      END IF
C
C  END OF MAIN LOOP -----------
      GO TO 1000
C
C  SEARCH TERMINATED
 9000 CONTINUE
      WRITE(ISCE,800) MAXN,LOOP,IGS,NLOOP
      WRITE(*,800) MAXN,LOOP,IGS,NLOOP
      GO TO 9999
 9100 CONTINUE
      WRITE(ISCE,810) PCENTO*100.,KSTOP
      WRITE(*,810) PCENTO*100.,KSTOP
      GO TO 9999
 9200 WRITE(ISCE,820) GNRNG*100.
      WRITE(*,820) GNRNG*100.
 9999 CONTINUE
C
C  PRINT THE FINAL PARAMETER ESTIMATE AND ITS FUNCTION VALUE
      WRITE(ISCE,830)
      WRITE(ISCE,510) (XNAME(J),J=1,NOPT)
      WRITE(ISCE,520) BESTF,(BESTX(J),J=1,NOPT)
      WRITE(*,830)
      WRITE(*,510) (XNAME(J),J=1,NOPT)
      WRITE(*,520) BESTF,(BESTX(J),J=1,NOPT)
      AF = BESTF
      DO J = 1, NOPT
        A(J) = BESTX(J)
      END DO
10000 CONTINUE
C
C  END OF SUBROUTINE SCEUA
      RETURN
  500 FORMAT(//,'*** PRINT THE INITIAL POINT AND ITS CRITERION ',
     &       'VALUE ***')
  510 FORMAT(/,' CRITERION',100(2X,A4,2X),/1X,80(1H-))
  520 FORMAT(F8.3,100F8.3)
  600 FORMAT(//,1X,'*** PRINT THE RESULTS OF THE SCE SEARCH ***')
  610 FORMAT(/,1X,'LOOP',1X,'TRIALS',1X,'COMPLXS',1X,'BEST F',1X,
     &       'WORST F',1X,'PAR RNG',1X,100(2X,A4,2X))
  630 FORMAT(I5,1X,I5,3X,I5,3F8.3,100(F8.3))
  650 FORMAT(/,1X,'POPULATION AT LOOP ',I3,/,1X,22(1H-))
  660 FORMAT(F8.3,100(F8.3))
  800 FORMAT(//,1X,'*** OPTIMIZATION SEARCH TERMINATED BECAUSE THE',
     &       ' LIMIT ON THE MAXIMUM',/,5X,'NUMBER OF TRIALS ',I5,
     &       ' EXCEEDED.  SEARCH WAS STOPPED AT',/,5X,'SUB-COMPLEX ',
     &       I3,' OF COMPLEX ',I3,' IN SHUFFLING LOOP ',I3,' ***')
  810 FORMAT(//,1X,'*** OPTIMIZATION TERMINATED BECAUSE THE CRITERION',
     &       ' VALUE HAS NOT CHANGED ',/,5X,F5.2,' PERCENT IN',I3,
     &       ' SHUFFLING LOOPS ***')
  820 FORMAT(//,1X,'*** OPTIMIZATION TERMINATED BECAUSE THE POPULATION',
     &       ' HAS CONVERGED INTO ',/,4X,F5.2,' PERCENT OF THE',
     &       ' FEASIBLE SPACE ***')
  830 FORMAT(//,'*** PRINT THE FINAL PARAMETER ESTIMATE AND ITS',
     &       ' CRITERION VALUE ***')
      END
C
C
C
C====================================================================
      SUBROUTINE CCE(NOPT,NPS,S,SF,BL,BU,XNSTD,ICALL,MAXN,ISEED,IPARM)
C


C  ALGORITHM GENERATE A NEW POINT(S) FROM A SUB-COMPLEX
C
C  SUB-COMPLEX VARIABLES
      DIMENSION S(50,IPARM),SF(50),BU(IPARM)
      DIMENSION BL(IPARM),XNSTD(IPARM)

C
C  LIST OF LOCAL VARIABLES
C    WO(.) = THE WORST POINT OF THE SIMPLEX
C    FW = FUNCTION VALUE OF THE WORST POINT
C    CE(.) = THE CENTROID OF THE SIMPLEX EXCLUDING WO
C    SNEW(.) = NEW POINT GENERATED FROM THE SIMPLEX
C    STEP(.) = VECTOR FROM WO TO CE
C
      DIMENSION WO(IPARM),CE(IPARM),SNEW(IPARM),STEP(IPARM)
C
C  EQUIVALENCE OF VARIABLES FOR READABILTY OF CODE
      N = NPS
      M = NOPT
C
C  IDENTIFY THE WORST POINT WO OF THE SUB-COMPLEX S
C  COMPUTE THE CENTROID CE OF THE REMAINING POINTS
C  COMPUTE STEP, THE VECTOR BETWEEN WO AND CE
C  IDENTIFY THE WORST FUNCTION VALUE FW
      DO J = 1, M
        WO(J) = S(N,J)
        CE(J) = 0.0
        DO I = 1, N-1
          CE(J) = CE(J) + S(I,J)
        END DO
        CE(J) = CE(J)/DBLE(N-1)
        STEP(J) = CE(J) - WO(J)
      END DO
      FW = SF(N)
C
C  COMPUTE THE NEW POINT SNEW
C
C  FIRST TRY A REFLECTION STEP
      DO J = 1, M
        SNEW(J) = WO(J) + 2. * STEP(J)
      END DO
C
C  CHECK IF SNEW IS WITHIN BOUND OR NOT
      IBOUND = 0
      DO J = 1, M
        IF (SNEW(J) .GT. BU(J) .OR. SNEW(J) .LT. BL(J)) THEN
          IBOUND = 1
          GO TO 50
        END IF
      END DO
   50 CONTINUE
C
C
C  SNEW IS OUTSIDE THE BOUND,
C  CHOOSE A POINT AT RANDOM WITHIN FEASIBLE REGION ACCORDING TO
C  A NORMAL DISTRIBUTION WITH BEST POINT OF THE SUB-COMPLEX
C  AS MEAN AND STANDARD DEVIATION OF THE POPULATION AS STD
      IF (IBOUND .EQ. 1) THEN
        DO J = 1, M
   60     R = GASDEV(ISEED)
          SNEW(J) = S(1,J) + XNSTD(J)*R*(BU(J)-BL(J))
          IF (SNEW(J) .GT. BU(J) .OR. SNEW(J) .LT. BL(J)) GO TO 60
        END DO
      END IF
C
C
C  COMPUTE THE FUNCTION VALUE AT SNEW
      FNEW = FUNCTN(NOPT,SNEW)
      !print *,'function new',SNEW(13),BL(13),BU(13)

      ICALL = ICALL + 1
C
C  COMPARE FNEW WITH THE WORST FUNCTION VALUE FW
C
C  FNEW IS LESS THAN FW, ACCEPT THE NEW POINT SNEW AND RETURN
      IF (FNEW .LE. FW) GO TO 9000
      IF (ICALL .GE. MAXN) GO TO 9100
C
C
C  FNEW IS GREATER THAN FW, SO TRY A CONTRACTION STEP
      DO J = 1, M
        SNEW(J) = WO(J) + 0.5 * STEP(J)
      END DO
C
C  COMPUTE THE FUNCTION VALUE OF THE CONTRACTED POINT
      FNEW = FUNCTN(NOPT,SNEW)
      ICALL = ICALL + 1
C
C  COMPARE FNEW TO THE WORST VALUE FW
C  IF FNEW IS LESS THAN OR EQUAL TO FW, THEN ACCEPT THE POINT AND RETURN
      IF (FNEW .LE. FW) GO TO 9000
      IF (ICALL .GE. MAXN) GO TO 9100
C
C
C  IF BOTH REFLECTION AND CONTRACTION FAIL, CHOOSE ANOTHER POINT
C  ACCORDING TO A NORMAL DISTRIBUTION WITH BEST POINT OF THE SUB-COMPLEX
C  AS MEAN AND STANDARD DEVIATION OF THE POPULATION AS STD
      DO J = 1, M
  140   R = GASDEV(ISEED)
        SNEW(J) = S(1,J) + XNSTD(J)*R*(BU(J)-BL(J))
        IF (SNEW(J) .GT. BU(J) .OR. SNEW(J) .LT. BL(J)) GO TO 140
      END DO
C
C  COMPUTE THE FUNCTION VALUE AT THE RANDOM POINT
      FNEW = FUNCTN(NOPT,SNEW)
      ICALL = ICALL + 1
C
C
C  REPLACE THE WORST POINT BY THE NEW POINT
 9000 CONTINUE
      DO J = 1, M
        S(N,J) = SNEW(J)
      END DO
      SF(N) = FNEW
 9100 CONTINUE
C
C  END OF SUBROUTINE CCE
      RETURN
      END
C
C
C
C===================================================================
      SUBROUTINE PARSTT(NPT,NOPT,X,XNSTD,BOUND,GNRNG,IPCNVG,IPARM)
C
C  SUBROUTINE CHECKING FOR PARAMETER CONVERGENCE

      DIMENSION X(2000,IPARM),XMAX(IPARM),XMIN(IPARM)
      DIMENSION XMEAN(IPARM),XNSTD(IPARM),BOUND(IPARM)
      PARAMETER (DELTA = 1.0D-20,PEPS=1.0D-3)
C

C  COMPUTE MAXIMUM, MINIMUM AND STANDARD DEVIATION OF PARAMETER VALUES
      GSUM = 0.D0
      DO K = 1, NOPT
        XMAX(K) = -1.0D+20
        XMIN(K) = 1.0D+20
        XSUM1 = 0.D0
        XSUM2 = 0.D0
        DO I = 1, NPT
          XMAX(K) = AMAX1(X(I,K), XMAX(K))
          XMIN(K) = AMIN1(X(I,K), XMIN(K))
          XSUM1 = XSUM1 + X(I,K)
          XSUM2 = XSUM2 + X(I,K)*X(I,K)
        END DO
        XMEAN(K) = XSUM1 / DBLE(NPT)
        XNSTD(K) = (XSUM2 / DBLE(NPT) - XMEAN(K)*XMEAN(K))
        IF (XNSTD(K) .LE. DELTA) XNSTD(K) = DELTA
        XNSTD(K) = SQRT(XNSTD(K))
        XNSTD(K) = XNSTD(K) / BOUND(K)
        GSUM = GSUM + LOG( DELTA + (XMAX(K)-XMIN(K))/BOUND(K) )

      END DO
      GNRNG = DEXP(GSUM/DBLE(NOPT))
C
C  CHECK IF NORMALIZED STANDARD DEVIATION OF PARAMETER IS <= EPS
      IPCNVG = 0
      IF (GNRNG .LE. PEPS) THEN
        IPCNVG = 1
      END IF
C
C  END OF SUBROUTINE PARSTT
      RETURN
      END
C
C
C
C===================================================================
      SUBROUTINE NORMDIST(NPT,NOPT,X,XI,DIST,BOUND,IPARM)
C
C  SUBROUTINE COMPUTING NORMAILZIED DISTANCE FROM INITIAL POINT
C     X(.,.)  - POPULATION
C     XI(.)   - INITIAL POINT
C     DIST(.) - NORMALIZED DISTANCE FROM INITIAL POINT

      DIMENSION X(2000,IPARM),XI(IPARM),DIST(2000),BOUND(IPARM)
C

C  COMPUTE MAXIMUM, MINIMUM AND STANDARD DEVIATION OF PARAMETER VALUES
      DO K = 1, NPT
         DIST(K) = 0.
         DO I = 1, NOPT
            DIST(K) = DIST(K) + ABS(X(K,I) - XI(I))/BOUND(I)
         END DO
         DIST(K) = DIST(K) / NOPT
      END DO
C
C  END OF SUBROUTINE NORMDIST
      RETURN
      END
C
C
C
C====================================================================
      SUBROUTINE COMP(N,NPT,NGS1,NGS2,NPG,A,AF,B,BF,IPARM)
C
C
C  THIS SUBROUTINE REDUCE INPUT MATRIX A(N,NGS2*NPG) TO MATRIX
C  B(N,NGS1*NPG) AND VECTOR AF(NGS2*NPG) TO VECTOR BF(NGS1*NPG)

      DIMENSION A(2000,IPARM),AF(2000),B(2000,IPARM),BF(2000)


      DO IGS=1, NGS1
        DO IPG=1, NPG
          K1=(IPG-1)*NGS2 + IGS
          K2=(IPG-1)*NGS1 + IGS
          DO I=1, N
            B(K2,I) = A(K1,I)
          END DO
          BF(K2) = AF(K1)
        END DO
      END DO
C
      DO J=1, NPT
        DO I=1, N
          A(J,I) = B(J,I)
        END DO
        AF(J) = BF(J)
      END DO
C
C  END OF SUBROUTINE COMP
      RETURN
      END
C
C
C
C===================================================================
      SUBROUTINE SORT(N,M,RB,RA,IPARM)
C
C
C  SORTING SUBROUTINE ADAPTED FROM "NUMERICAL RECIPES"
C  BY W.H. PRESS ET AL., PP. 233-234
C
C  LIST OF VARIABLES
C     RA(.) = ARRAY TO BE SORTED
C     RB(.,.) = ARRAYS ORDERED CORRESPONDING TO REARRANGEMENT OF RA(.)
C     WK(.,.), IWK(.) = LOCAL VARIBLES
C

      DIMENSION RA(2000),RB(2000,IPARM),WK(2000,IPARM),IWK(2000)
C

      CALL INDEXX(N, RA, IWK)
      DO I = 1, N
        WK(I,1) = RA(I)
      END DO
      DO I = 1, N
        RA(I) = WK(IWK(I),1)
      END DO
      DO J = 1, M
        DO I = 1, N
          WK(I,J) = RB(I,J)
        END DO
      END DO
      DO J = 1, M
        DO I = 1, N
          RB(I,J) = WK(IWK(I),J)
        END DO
      END DO
C
C  END OF SUBROUTINE SORT
      RETURN
      END
C
C
C===========================================================
      SUBROUTINE SORT1(N,RA)
C
C
C  SORTING SUBROUTINE ADAPTED FROM "NUMERICAL RECIPES"
C  BY W.H. PRESS ET AL., PP. 231
C
C  LIST OF VARIABLES
C     RA(.) = INTEGER ARRAY TO BE SORTED
C
      DIMENSION RA(N)
C
      INTEGER RA, RRA
C
      L = (N / 2) + 1
      IR = N
   10 CONTINUE
      IF (L .GT. 1) THEN
      L = L - 1
      RRA = RA(L)
      ELSE
      RRA = RA(IR)
      RA(IR) = RA(1)
      IR = IR - 1
      IF (IR .EQ. 1) THEN
      RA(1) = RRA
      RETURN
      END IF
      END IF
      I = L
      J = L + L
   20 IF (J .LE. IR) THEN
      IF (J .LT. IR) THEN
      IF (RA(J) .LT. RA(J + 1)) J = J + 1
      END IF
      IF (RRA .LT. RA(J)) THEN
      RA(I) = RA(J)
      I = J
      J = J + J
      ELSE
      J = IR + 1
      END IF
      GOTO 20
      END IF
      RA(I) = RRA
      GOTO 10
C
C  END OF SUBROUTINE SORT1
      END
C
C
C
C=======================================================
      SUBROUTINE INDEXX(N, ARRIN, INDX)
C
C
C  THIS SUBROUTINE IS FROM "NUMERICAL RECIPES" BY PRESS ET AL.
      DIMENSION ARRIN(N), INDX(N)
C
      DO J = 1, N
        INDX(J) = J
      END DO
      L = (N / 2) + 1
      IR = N
   10 CONTINUE
      IF (L .GT. 1) THEN
      L = L - 1
      INDXT = INDX(L)
      Q = ARRIN(INDXT)
      ELSE
      INDXT = INDX(IR)
      Q = ARRIN(INDXT)
      INDX(IR) = INDX(1)
      IR = IR - 1
      IF (IR .EQ. 1) THEN
      INDX(1) = INDXT
      RETURN
      END IF
      END IF
      I = L
      J = L + L
   20 IF (J .LE. IR) THEN
      IF (J .LT. IR) THEN
      IF (ARRIN(INDX(J)) .LT. ARRIN(INDX(J + 1))) J = J + 1
      END IF
      IF (Q .LT. ARRIN(INDX(J))) THEN
      INDX(I) = INDX(J)
      I = J
      J = J + J
      ELSE
      J = IR + 1
      END IF
      GOTO 20
      END IF
      INDX(I) = INDXT
      GOTO 10
C
C  END OF SUBROUTINE INDEXX
      END
C
C
C
C==============================================================
      FUNCTION RAN1(IDUM)
C
C
C  THIS SUBROUTINE IS FROM "NUMERICAL RECIPES" BY PRESS ET AL.
      DIMENSION R(97)
      PARAMETER (M1 = 259200, IA1 = 7141, IC1 = 54773, RM1 =
     &3.8580247E-6)
      PARAMETER (M2 = 134456, IA2 = 8121, IC2 = 28411, RM2 =
     &7.4373773E-6)
      PARAMETER (M3 = 243000, IA3 = 4561, IC3 = 51349)
      SAVE
      DATA IFF / 0 /
      IF ((IDUM .LT. 0) .OR. (IFF .EQ. 0)) THEN
      IFF = 1
      IX1 = MOD(IC1 - IDUM,M1)
      IX1 = MOD((IA1 * IX1) + IC1,M1)
      IX2 = MOD(IX1,M2)
      IX1 = MOD((IA1 * IX1) + IC1,M1)
      IX3 = MOD(IX1,M3)
      DO J = 1, 97
        IX1 = MOD((IA1 * IX1) + IC1,M1)
        IX2 = MOD((IA2 * IX2) + IC2,M2)
        R(J) = (DBLE(IX1) + (DBLE(IX2) * RM2)) * RM1
      END DO
      IDUM = 1
      END IF
      IX1 = MOD((IA1 * IX1) + IC1,M1)
      IX2 = MOD((IA2 * IX2) + IC2,M2)
      IX3 = MOD((IA3 * IX3) + IC3,M3)
      J = 1 + ((97 * IX3) / M3)
      IF ((J .GT. 97) .OR. (J .LT. 1)) PAUSE
      RAN1 = R(J)
      R(J) = (DBLE(IX1) + (DBLE(IX2) * RM2)) * RM1
C
C  END OF SUBROUTINE RAN1
      RETURN
      END
C
C
C
C===============================================================
      FUNCTION GASDEV(IDUM)
C
C
C  THIS SUBROUTINE IS FROM "NUMERICAL RECIPES" BY PRESS ET AL.
      DATA ISET / 0 /
      IF (ISET .EQ. 0) THEN
    1 V1 = (2. * RAN1(IDUM)) - 1.
      V2 = (2. * RAN1(IDUM)) - 1.
      R = (V1 ** 2) + (V2 ** 2)
      IF (R .GE. 1.) GOTO 1

      FAC = SQRT(- ((2. * LOG(R)) / R))

      GSET = V1 * FAC
      GASDEV = V2 * FAC
      ISET = 1
      ELSE
      GASDEV = GSET
      ISET = 0
      END IF
C
C  END OF SUBROUTINE GASDEV
      RETURN
      END
